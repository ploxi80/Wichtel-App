<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Weihnachts-Wichteln</title>
    
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Mountains+of+Christmas:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">

    <style>
      body {
        font-family: 'Inter', sans-serif;
        background-color: #1a0505; /* Deep dark red/brown base */
        color: #fffaf0;
        overflow: hidden; /* Prevent scrolling during game */
        touch-action: manipulation;
        margin: 0;
      }
      .font-festive {
        font-family: 'Mountains of Christmas', serif;
      }
      .snow-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: none;
        z-index: 0;
      }
      .snowflake {
        position: absolute;
        top: -10px;
        background-color: white;
        border-radius: 50%;
        opacity: 0.8;
        animation: fall linear infinite;
      }
      @keyframes fall {
        to { transform: translateY(105vh); }
      }
      @keyframes glow {
        0% { box-shadow: 0 0 10px #fbbf24, 0 0 20px #d97706; }
        50% { box-shadow: 0 0 30px #fbbf24, 0 0 50px #b45309; }
        100% { box-shadow: 0 0 10px #fbbf24, 0 0 20px #d97706; }
      }
      .animate-glow {
        animation: glow 2s infinite ease-in-out;
      }
      @keyframes shake {
        0% { transform: translate(1px, 1px) rotate(0deg); }
        10% { transform: translate(-1px, -2px) rotate(-1deg); }
        20% { transform: translate(-3px, 0px) rotate(1deg); }
        30% { transform: translate(3px, 2px) rotate(0deg); }
        40% { transform: translate(1px, -1px) rotate(1deg); }
        50% { transform: translate(-1px, 2px) rotate(-1deg); }
        60% { transform: translate(-3px, 1px) rotate(0deg); }
        70% { transform: translate(3px, 1px) rotate(-1deg); }
        80% { transform: translate(-1px, -1px) rotate(1deg); }
        90% { transform: translate(1px, 2px) rotate(0deg); }
        100% { transform: translate(1px, -2px) rotate(-1deg); }
      }
      .animate-shake {
        animation: shake 0.5s infinite;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .animate-fade-in {
        animation: fadeIn 0.5s ease-out forwards;
      }
      @keyframes bounceIn {
        0% { opacity: 0; transform: scale(0.3); }
        50% { opacity: 1; transform: scale(1.05); }
        70% { transform: scale(0.9); }
        100% { transform: scale(1); }
      }
      .animate-bounce-in {
        animation: bounceIn 0.8s cubic-bezier(0.215, 0.610, 0.355, 1.000) both;
      }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "lucide-react": "https://esm.sh/lucide-react@^0.562.0"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useCallback } = React;

      // --- TYPES & ENUMS ---
      const GamePhase = {
        SETUP: 'SETUP',
        PLAYING: 'PLAYING',
        FINISHED: 'FINISHED'
      };

      // --- ICONS (SVG Components) ---
      const IconBase = ({ children, className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
          {children}
        </svg>
      );

      const GiftIcon = () => <IconBase className="w-6 h-6"><path d="M20 12v10H4V12"/><path d="M2 7h20v5H2z"/><path d="M12 22V7"/><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"/><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"/></IconBase>;
      const ClockIcon = () => <IconBase className="w-6 h-6"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></IconBase>;
      const UsersIcon = () => <IconBase className="w-6 h-6"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></IconBase>;
      const PlayIcon = () => <IconBase className="w-6 h-6 fill-current"><polygon points="5 3 19 12 5 21 5 3"/></IconBase>;
      const DeleteIcon = () => <IconBase className="w-4 h-4"><path d="M18 6 6 18"/><path d="m6 6 18 18"/></IconBase>;
      const MaximizeIcon = () => <IconBase className="w-6 h-6"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></IconBase>;
      const MinimizeIcon = () => <IconBase className="w-6 h-6"><path d="M8 3v3a2 2 0 0 1-2 2H3"/><path d="M21 8h-3a2 2 0 0 1-2-2V3"/><path d="M3 16h3a2 2 0 0 1 2 2v3"/><path d="M16 21v-3a2 2 0 0 1 2-2h3"/></IconBase>;
      const MusicIcon = () => <IconBase className="w-5 h-5"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></IconBase>;
      const MusicOffIcon = () => <IconBase className="w-5 h-5"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></IconBase>;

      // --- SOUND UTILS ---
      let audioCtx = null;
      let bgMusic = null;

      const getCtx = () => {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioCtx;
      };

      const initAudio = () => {
          const ctx = getCtx();
          if (ctx.state === 'suspended') {
              ctx.resume();
          }
      };

      const playBackgroundMusic = () => {
        if (!bgMusic) {
          bgMusic = new Audio('music.mp3');
          bgMusic.loop = true;
          bgMusic.volume = 0.4; 
        }
        bgMusic.currentTime = 0;
        bgMusic.play().catch(e => console.warn("Background music could not play (autoplay policy?):", e));
      };

      const stopBackgroundMusic = () => {
        if (bgMusic) {
          bgMusic.pause();
          bgMusic.currentTime = 0;
        }
      };

      const playTick = () => {
        const ctx = getCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.05);
        gain.gain.setValueAtTime(0.1, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.05);
      };

      const playChime = () => {
        const ctx = getCtx();
        const now = ctx.currentTime;
        const notes = [523.25, 659.25, 783.99, 987.77]; 
        notes.forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'triangle';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.05, now + 0.1 + (i * 0.05));
          gain.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start(now);
          osc.stop(now + 2.0);
        });
      };

      const playAlarmLoop = () => {
        const ctx = getCtx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sawtooth';
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();

        let isRunning = true;
        const sweep = () => {
          if (!isRunning) return;
          const now = ctx.currentTime;
          osc.frequency.setValueAtTime(440, now);
          osc.frequency.linearRampToValueAtTime(880, now + 0.5);
          osc.frequency.linearRampToValueAtTime(440, now + 1.0);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.linearRampToValueAtTime(0.05, now + 0.5);
          gain.gain.linearRampToValueAtTime(0.1, now + 1.0);
        };
        sweep();
        const intervalId = setInterval(() => { if (isRunning) sweep(); }, 1000);

        return () => {
          isRunning = false;
          clearInterval(intervalId);
          try {
            const now = ctx.currentTime;
            gain.gain.cancelScheduledValues(now);
            gain.gain.setValueAtTime(gain.gain.value, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.stop(now + 0.1);
            setTimeout(() => { osc.disconnect(); gain.disconnect(); }, 200);
          } catch (e) {}
        };
      };

      const playGameEnd = () => {
          const ctx = getCtx();
          const now = ctx.currentTime;
          const melody = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50];
          const timing = [0, 0.2, 0.4, 0.6, 0.9, 1.2];
          melody.forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.type = 'square';
              osc.frequency.value = freq;
              const startTime = now + timing[i];
              const duration = 0.3;
              gain.gain.setValueAtTime(0, startTime);
              gain.gain.linearRampToValueAtTime(0.05, startTime + 0.05);
              gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.start(startTime);
              osc.stop(startTime + duration);
          });
      };

      // --- GAME LOGIC ---
      const fillerCommands = [
        "Mischen...", "Wichteln...", "Wer bekommt was?", "Achtung...",
        "Spannung...", "Geschenke...", "Rentiere...", "Schneefall...", "WÃ¼rfeln..."
      ];

      const getRandomCommand = (players) => {
        const baseCommands = [
          { text: "Alle geben ihr Geschenk 1 Platz nach LINKS! â¬…ï¸", type: 'DIRECTIONAL' },
          { text: "Alle geben ihr Geschenk 1 Platz nach RECHTS! âž¡ï¸", type: 'DIRECTIONAL' },
          { text: "Alle geben ihr Geschenk 2 PlÃ¤tze nach LINKS! â¬…ï¸â¬…ï¸", type: 'DIRECTIONAL' },
          { text: "Alle geben ihr Geschenk 2 PlÃ¤tze nach RECHTS! âž¡ï¸âž¡ï¸", type: 'DIRECTIONAL' },
          { text: "Tausche mit der Person direkt gegenÃ¼ber! â†”ï¸", type: 'POSITIONAL' },
          { text: "Tausche mit irgendeiner Person! â†”ï¸", type: 'POSITIONAL' },
          { text: "Alle Geschenke in die Mitte und schnell ein Neues nehmen! ðŸŒªï¸", type: 'CHAOS' },
          { text: "Tausche mit der 3. Person links von dir! ðŸ”„", type: 'POSITIONAL' },
          { text: "Tausche mit der 2. Person rechts von dir! ðŸ”„", type: 'POSITIONAL' },
          { text: "Behalte dein Geschenk! â˜•", type: 'POSITIONAL' },
        ];

        if (players.length >= 2) {
          const p1Index = Math.floor(Math.random() * players.length);
          let p2Index = Math.floor(Math.random() * players.length);
          while (p1Index === p2Index) {
             p2Index = Math.floor(Math.random() * players.length);
          }
          baseCommands.push({ text: `${players[p1Index].name} tauscht mit ${players[p2Index].name}! ðŸ¤`, type: 'SWAP' });
          const p3 = players[Math.floor(Math.random() * players.length)];
          baseCommands.push({ text: `${p3.name} muss mit dem linken Nachbarn tauschen! ðŸ‘ˆ`, type: 'SWAP' });
        }

        if (players.length > 3) {
          const shuffled = [...players].sort(() => 0.5 - Math.random());
          const selected = shuffled.slice(0, 3);
          const names = selected.map(p => p.name).join(', ');
          const isRight = Math.random() > 0.5;
          const directionText = isRight ? "rechtsherum" : "linksherum";
          const arrow = isRight ? "âž¡ï¸" : "â¬…ï¸";
          baseCommands.push({ text: `${names} tauschen im Kreis ${directionText}! ${arrow}`, type: 'SWAP' });
          baseCommands.push({ text: `${names} tauschen im Kreis ${directionText}! ${arrow}`, type: 'SWAP' });
        }

        return baseCommands[Math.floor(Math.random() * baseCommands.length)];
      };

      // --- COMPONENTS ---
      const Snowfall = () => {
        const [flakes, setFlakes] = useState([]);
        useEffect(() => {
          setFlakes(Array.from({ length: 50 }, (_, i) => i));
        }, []);
        return (
          <div className="snow-container" aria-hidden="true">
            {flakes.map((i) => {
              const left = Math.random() * 100;
              const duration = 5 + Math.random() * 10;
              const delay = Math.random() * 5;
              const size = 3 + Math.random() * 5;
              return <div key={i} className="snowflake" style={{ left: `${left}%`, animationDuration: `${duration}s`, animationDelay: `${delay}s`, width: `${size}px`, height: `${size}px` }} />;
            })}
          </div>
        );
      };

      const Confetti = () => {
        const canvasRef = useRef(null);
        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d');
          if (!ctx) return;
          let particles = [];
          const colors = ['#fbbf24', '#ef4444', '#ffffff', '#22c55e'];
          const createParticle = () => ({
            x: Math.random() * canvas.width, y: -20, size: Math.random() * 10 + 5,
            color: colors[Math.floor(Math.random() * colors.length)],
            speedY: Math.random() * 3 + 2, speedX: Math.random() * 4 - 2,
            rotation: Math.random() * 360, rotationSpeed: Math.random() * 10 - 5
          });
          for (let i = 0; i < 100; i++) particles.push(createParticle());
          const animate = () => {
            if (!canvas) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach((p, index) => {
              p.y += p.speedY; p.x += p.speedX; p.rotation += p.rotationSpeed;
              ctx.save(); ctx.translate(p.x, p.y); ctx.rotate((p.rotation * Math.PI) / 180);
              ctx.fillStyle = p.color; ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
              ctx.restore();
              if (p.y > canvas.height) particles[index] = createParticle();
            });
            requestAnimationFrame(animate);
          };
          const handleResize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
          handleResize();
          window.addEventListener('resize', handleResize);
          const animId = requestAnimationFrame(animate);
          return () => { window.removeEventListener('resize', handleResize); cancelAnimationFrame(animId); };
        }, []);
        return <canvas ref={canvasRef} className="fixed inset-0 pointer-events-none z-50" />;
      };

      // --- APP COMPONENT ---
      const App = () => {
        const [phase, setPhase] = useState(GamePhase.SETUP);
        const [players, setPlayers] = useState([]);
        const [newName, setNewName] = useState('');
        const [duration, setDuration] = useState(15);
        const [isFullscreen, setIsFullscreen] = useState(false);
        const [isMusicEnabled, setIsMusicEnabled] = useState(true);
        const [currentCommand, setCurrentCommand] = useState("DrÃ¼cke den Knopf!");
        const [isSpinning, setIsSpinning] = useState(false);
        const [lastCommandType, setLastCommandType] = useState('neutral');
        const [turnQueue, setTurnQueue] = useState([]);
        const [currentPlayer, setCurrentPlayer] = useState(null);

        const endTimeRef = useRef(null);
        const timerIntervalRef = useRef(null);
        const alarmStopRef = useRef(null);

        const toggleFullscreen = () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().then(() => setIsFullscreen(true)).catch(e => console.error(e));
          } else {
            document.exitFullscreen().then(() => setIsFullscreen(false));
          }
        };

        useEffect(() => {
          const handleFsChange = () => setIsFullscreen(!!document.fullscreenElement);
          document.addEventListener('fullscreenchange', handleFsChange);
          return () => document.removeEventListener('fullscreenchange', handleFsChange);
        }, []);

        const addPlayer = () => {
          initAudio();
          if (newName.trim()) {
            setPlayers([...players, { id: Date.now().toString(), name: newName.trim() }]);
            setNewName('');
          }
        };

        const removePlayer = (id) => {
          setPlayers(players.filter(p => p.id !== id));
        };

        const shuffleArray = (array) => {
          const newArr = [...array];
          for (let i = newArr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
          }
          return newArr;
        };

        const startGame = () => {
          initAudio();
          if (players.length < 2) {
            alert("Bitte mindestens 2 Spieler hinzufÃ¼gen!");
            return;
          }
          const shuffled = shuffleArray(players);
          setTurnQueue(shuffled.slice(1));
          setCurrentPlayer(shuffled[0]);
          endTimeRef.current = Date.now() + (duration * 60 * 1000);
          setPhase(GamePhase.PLAYING);
          setCurrentCommand("Bereit machen...");
          if (isMusicEnabled) playBackgroundMusic();
        };

        const stopAlarm = () => {
          if (alarmStopRef.current) {
            alarmStopRef.current();
            alarmStopRef.current = null;
          }
        };

        useEffect(() => {
          if (phase === GamePhase.PLAYING) {
            timerIntervalRef.current = window.setInterval(() => {
              if (endTimeRef.current && Date.now() >= endTimeRef.current) {
                stopAlarm();
                stopBackgroundMusic();
                setPhase(GamePhase.FINISHED);
                playGameEnd();
                if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
              }
            }, 1000);
          }
          return () => {
            if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
            stopAlarm();
          };
        }, [phase]);

        const advanceTurn = () => {
          let nextQueue = [...turnQueue];
          if (nextQueue.length === 0) {
            nextQueue = shuffleArray(players);
            if (players.length > 1 && nextQueue[0].id === currentPlayer?.id) {
               [nextQueue[0], nextQueue[1]] = [nextQueue[1], nextQueue[0]];
            }
          }
          setTurnQueue(nextQueue.slice(1));
          setCurrentPlayer(nextQueue[0]);
        };

        const handleWichtelnClick = useCallback(() => {
          if (isSpinning) return;
          stopAlarm();
          initAudio(); 
          setIsSpinning(true);
          if (navigator.vibrate) navigator.vibrate(50);

          let spinCount = 0;
          const maxSpins = 20; 
          const spinInterval = window.setInterval(() => {
            const randomFiller = fillerCommands[Math.floor(Math.random() * fillerCommands.length)];
            setCurrentCommand(randomFiller);
            playTick(); 
            spinCount++;
            if (spinCount >= maxSpins) {
              clearInterval(spinInterval);
              const finalCmd = getRandomCommand(players);
              setCurrentCommand(finalCmd.text);
              setLastCommandType(finalCmd.type);
              setIsSpinning(false);
              if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
              
              if (finalCmd.type === 'CHAOS') {
                alarmStopRef.current = playAlarmLoop();
              } else {
                playChime();
              }
              advanceTurn();
            }
          }, 100);
        }, [isSpinning, players, turnQueue, currentPlayer]);

        const resetGame = () => {
          stopAlarm();
          stopBackgroundMusic();
          setPhase(GamePhase.SETUP);
          setCurrentCommand("DrÃ¼cke den Knopf!");
          setLastCommandType('neutral');
          setTurnQueue([]);
          setCurrentPlayer(null);
        };

        return (
          <div className="min-h-screen relative flex flex-col items-center justify-center p-4">
            <Snowfall />
            <div className="absolute inset-0 bg-gradient-to-b from-red-950 via-slate-900 to-black opacity-90 -z-10" />

            <button 
              onClick={toggleFullscreen}
              className="fixed top-4 right-4 z-50 text-white/50 hover:text-white transition-colors bg-black/20 p-2 rounded-full"
              title="Vollbild umschalten"
            >
              {isFullscreen ? <MinimizeIcon /> : <MaximizeIcon />}
            </button>

            {phase === GamePhase.SETUP && (
              <div className="w-full max-w-md bg-white/10 backdrop-blur-md rounded-2xl p-6 shadow-2xl border border-white/20 animate-fade-in">
                <header className="text-center mb-8">
                  <h1 className="font-festive text-5xl text-amber-400 drop-shadow-lg mb-2">Wichteln</h1>
                  <p className="text-red-200 font-light">Das Tisch-Partyspiel</p>
                </header>

                <div className="space-y-6">
                  <div className="space-y-2">
                    <label className="flex items-center text-amber-100 font-semibold gap-2">
                      <UsersIcon /> Wer spielt mit?
                    </label>
                    <div className="flex gap-2">
                      <input
                        type="text"
                        value={newName}
                        onChange={(e) => setNewName(e.target.value)}
                        onKeyDown={(e) => e.key === 'Enter' && addPlayer()}
                        placeholder="Namen eingeben..."
                        className="flex-1 bg-white/5 border border-white/20 rounded-lg px-4 py-2 text-white placeholder-white/30 focus:outline-none focus:ring-2 focus:ring-amber-500"
                      />
                      <button 
                        onClick={addPlayer}
                        className="bg-amber-600 hover:bg-amber-500 text-white px-4 py-2 rounded-lg font-bold transition-colors"
                      >
                        +
                      </button>
                    </div>
                    
                    <div className="flex flex-wrap gap-2 mt-2 max-h-32 overflow-y-auto">
                      {players.map(player => (
                        <span key={player.id} className="flex items-center gap-2 bg-red-900/50 border border-red-700/50 px-3 py-1 rounded-full text-sm">
                          {player.name}
                          <button onClick={() => removePlayer(player.id)} className="text-red-300 hover:text-white">
                            <DeleteIcon />
                          </button>
                        </span>
                      ))}
                      {players.length === 0 && <span className="text-white/30 text-sm italic">Noch keine Spieler...</span>}
                    </div>
                  </div>

                  <div className="space-y-2">
                    <label className="flex items-center text-amber-100 font-semibold gap-2">
                      <ClockIcon /> Spieldauer: {duration} Minuten
                    </label>
                    <input
                      type="range"
                      min="1"
                      max="30"
                      step="1"
                      value={duration}
                      onChange={(e) => setDuration(parseInt(e.target.value))}
                      className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer accent-amber-500"
                    />
                    <div className="flex justify-between text-xs text-white/40">
                      <span>1 Min</span>
                      <span>30 Min</span>
                    </div>
                  </div>

                  <div className="flex items-center justify-between bg-black/20 p-3 rounded-lg border border-white/10">
                    <label className="flex items-center gap-2 text-amber-100 font-semibold cursor-pointer select-none">
                      {isMusicEnabled ? <MusicIcon /> : <MusicOffIcon />}
                      Hintergrundmusik
                    </label>
                    <button 
                      onClick={() => setIsMusicEnabled(!isMusicEnabled)}
                      className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none ${isMusicEnabled ? 'bg-green-600' : 'bg-gray-600'}`}
                    >
                      <span className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${isMusicEnabled ? 'translate-x-6' : 'translate-x-1'}`} />
                    </button>
                  </div>

                  <button
                    onClick={startGame}
                    disabled={players.length < 2}
                    className={`w-full py-4 rounded-xl text-xl font-festive font-bold shadow-xl transition-all transform hover:scale-[1.02] ${
                      players.length < 2 
                        ? 'bg-gray-600 cursor-not-allowed opacity-50' 
                        : 'bg-gradient-to-r from-green-700 to-emerald-600 hover:from-green-600 hover:to-emerald-500 text-white'
                    }`}
                  >
                    <div className="flex items-center justify-center gap-2">
                      <PlayIcon /> Spiel starten
                    </div>
                  </button>
                </div>
              </div>
            )}

            {phase === GamePhase.PLAYING && (
              <div className="w-full max-w-lg flex flex-col items-center gap-8 animate-fade-in text-center">
                <div className={`w-full min-h-[160px] flex items-center justify-center bg-black/30 backdrop-blur-sm rounded-3xl p-8 border-2 shadow-[0_0_50px_rgba(251,191,36,0.1)] transition-colors duration-300 ${lastCommandType === 'CHAOS' ? 'border-red-500 bg-red-900/20' : 'border-amber-500/30'}`}>
                  <h2 className={`text-2xl md:text-4xl font-bold leading-tight transition-all duration-100 ${
                    isSpinning ? 'text-white/70 blur-[1px]' : 'text-amber-300 drop-shadow-[0_0_10px_rgba(251,191,36,0.5)] scale-105'
                  } ${lastCommandType === 'CHAOS' ? 'text-red-500 animate-pulse font-black uppercase tracking-widest' : ''}`}>
                    {currentCommand}
                  </h2>
                </div>

                <div className="text-center animate-fade-in">
                   <p className="text-amber-100/60 uppercase text-xs tracking-widest mb-1">An der Reihe ist</p>
                   <h3 className="text-3xl font-festive text-white drop-shadow-md">
                     {currentPlayer?.name || "..."}
                   </h3>
                </div>

                <button
                  onClick={handleWichtelnClick}
                  disabled={isSpinning}
                  className={`
                    relative w-64 h-64 rounded-full border-8 border-amber-600/50 shadow-[0_0_60px_rgba(217,119,6,0.4)]
                    bg-gradient-to-br from-amber-300 via-amber-500 to-amber-700
                    text-red-950 font-festive text-5xl font-bold tracking-wider
                    transition-all duration-100
                    ${isSpinning ? 'animate-shake scale-95 opacity-90' : 'animate-glow hover:scale-105 active:scale-95'}
                  `}
                >
                  <span className="drop-shadow-sm">WICHTELN!</span>
                  <div className="absolute top-0 left-0 w-full h-full rounded-full bg-gradient-to-b from-white/30 to-transparent pointer-events-none" />
                </button>

                <p className="text-white/40 text-sm mt-8">Der Timer lÃ¤uft im Hintergrund... ðŸ¤«</p>
              </div>
            )}

            {phase === GamePhase.FINISHED && (
              <>
                <Confetti />
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-md animate-fade-in">
                  <div className="bg-gradient-to-b from-red-900 to-red-950 p-8 md:p-12 rounded-3xl border-4 border-amber-500 text-center max-w-2xl shadow-2xl transform scale-100 animate-bounce-in">
                    <div className="mb-6 flex justify-center"><GiftIcon /></div>
                    <h2 className="font-festive text-6xl text-amber-400 mb-6 drop-shadow-xl">Die Zeit ist um!</h2>
                    <p className="text-xl md:text-2xl text-white font-light leading-relaxed mb-8">
                      Das Geschenk, das ihr jetzt in den HÃ¤nden haltet, gehÃ¶rt <strong className="text-amber-300 font-bold">EUCH</strong>!
                    </p>
                    <p className="text-3xl font-festive text-white mb-12">Frohe Weihnachten! ðŸŽ„</p>
                    <button onClick={resetGame} className="bg-white text-red-900 px-8 py-3 rounded-full font-bold hover:bg-amber-100 transition-colors shadow-lg">Neues Spiel starten</button>
                  </div>
                </div>
              </>
            )}
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js');
  }
</script>
<link rel="manifest" href="manifest.json">
</body>
</html>